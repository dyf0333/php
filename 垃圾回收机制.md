# php垃圾回收机制浅析（5.2-5.3版本）

php垃圾回收机制之前就了解过了，特此记录一下重点，
这部分将说明PHP 5.3的垃圾回收机制（也就是GC）的特点。
>（php7貌似目前没有很多关于垃圾回收机制的更多资料）

首先了解来源是从php官网的解释文档来的----源自php.net的解释
>http://php.net/manual/zh/features.gc.php


### 引用计数RC（ 5.2 的概念）
     
每个php变量存在一个叫"zval"的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。
     
`第一个是 "is_ref"`是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。

`第二个额外字节是"refcount"。`用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。

### 垃圾回收算法，缓存池（5.3解决5.2的循环引用的方案）

```
1、并不是每次refcount减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。
2、可以解决循环引用问题。
3、可以总将内存泄露保持在一个阈值以下。
```

>当根缓冲区满额时，PHP就会执行垃圾回收，此回收算法如下：
```
1、对每个根缓冲区中的根zval按照深度优先遍历算法遍历所有能遍历到的zval，并将每个zval的refcount减1，同时为了避免对同一zval多次减1（因为可能不同的根能遍历到同一个zval），每次对某个zval减1后就对其标记为“已减”。
2、再次对每个缓冲区中的根zval深度优先遍历，如果某个zval的refcount不为0，则对其加1，否则保持其为0。
3、清空根缓冲区中的所有根（注意是把这些zval从缓冲区中清除而不是销毁它们），然后销毁所有refcount为0的zval，并收回其内存。
```